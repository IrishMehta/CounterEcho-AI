"""
Vulnerability Assessment Module

This module calculates vulnerability scores for users based on network centrality
and community density metrics.

Community-Camp Mapping:
- RU/CH CAMP: [C3, C7, C21, C12]
- LEFT CAMP: [C25, C10, C1, C5]
- RIGHT CAMP: [C2, C6]
"""

import pandas as pd
import networkx as nx
import logging
from typing import Dict

logger = logging.getLogger(__name__)


class VulnerabilityAssessor:
    """Calculates vulnerability score based on network and narrative metrics."""
    
    def __init__(self, graph: nx.Graph, nodes_df: pd.DataFrame):
        """
        Initialize vulnerability assessor.
        
        Args:
            graph: NetworkX graph (retweet network)
            nodes_df: DataFrame with node_id and community columns
        """
        self.G = graph
        self.nodes_df = nodes_df.set_index('Id') if 'Id' in nodes_df.columns else nodes_df.set_index('node_id')
        
        logger.info("Calculating network metrics...")
        self._calculate_metrics()
        logger.info("Vulnerability Assessor initialized")
    
    def _calculate_metrics(self):
        """Pre-compute network metrics for vulnerability assessment."""
        logger.info("Computing centrality...")
        self.centrality = nx.degree_centrality(self.G)
        
        logger.info("Computing community densities...")
        self.community_density = {}
        for community_id in self.nodes_df['community'].unique():
            members = self.nodes_df[self.nodes_df['community'] == community_id].index.tolist()
            members = [m for m in members if m in self.G]
            if len(members) > 1:
                subgraph = self.G.subgraph(members)
                self.community_density[community_id] = nx.density(subgraph)
            else:
                self.community_density[community_id] = 0.0
        
        logger.debug(f"Computed density for {len(self.community_density)} communities")
    
    def get_vulnerability_score(self, user_id: str) -> float:
        """
        Calculate vulnerability score for a user.
        
        Higher score = more vulnerable (more likely to be persuaded)
        
        Factors:
        - Moderate centrality -> high vulnerability (engaged but not core)
        - Low community density -> high vulnerability
        - Very low degree (isolated users) -> low vulnerability (inactive/bots)
        
        The vulnerability follows an inverted U-shape with respect to centrality:
        - Very low centrality (isolated) -> LOW vulnerability (disengaged)
        - Moderate centrality (peripheral but active) -> HIGH vulnerability (persuadable)
        - Very high centrality (core) -> LOW vulnerability (entrenched)
        
        Args:
            user_id: User identifier
            
        Returns:
            Vulnerability score (0-1)
        """
        user_id = str(user_id)
        
        if user_id not in self.G:
            logger.error(f"User {user_id} not found in graph")
            raise ValueError(f"User {user_id} not found in graph")
        
        centrality_score = self.centrality.get(user_id, 0)
        max_centrality = max(self.centrality.values()) if self.centrality else 1
        normalized_centrality = centrality_score / max_centrality if max_centrality > 0 else 0
        
        # Get user degree to check for isolation
        degree = self.G.degree(user_id)
        
        logger.debug(f"User {user_id} degree: {degree}, centrality: {centrality_score:.4f} (normalized: {normalized_centrality:.4f})")
        
        try:
            community_id = self.nodes_df.loc[user_id, 'community']
            density = self.community_density.get(community_id)
            if density is None:
                logger.error(f"No density found for community {community_id}")
                raise ValueError(f"No density found for community {community_id}")
            logger.debug(f"User {user_id} community {community_id} density: {density:.4f}")
        except KeyError:
            logger.error(f"User {user_id} not found in nodes dataframe")
            raise ValueError(f"User {user_id} not found in nodes dataframe")
        
        # Handle isolated users (degree <= 2) - they are NOT vulnerable (likely inactive/bots)
        if degree <= 2:
            vulnerability = 0.1  # Very low vulnerability for isolated users
            logger.debug(f"User {user_id} is isolated (degree={degree}), setting low vulnerability: {vulnerability:.4f}")
        else:
            # Inverted U-shape: moderate centrality = high vulnerability
            # Use a quadratic function: vulnerability peaks around 0.3-0.4 normalized centrality
            centrality_component = 4 * normalized_centrality * (1 - normalized_centrality)
            
            # Community density component: sparse communities = higher vulnerability
            density_component = 1 - density
            
            # Combine components (weighted: 60% centrality pattern, 40% community structure)
            vulnerability = 0.6 * centrality_component + 0.4 * density_component
            
            logger.debug(f"User {user_id} vulnerability components: centrality={centrality_component:.4f}, density={density_component:.4f}")
        
        logger.debug(f"User {user_id} final vulnerability score: {vulnerability:.4f}")
        
        return vulnerability